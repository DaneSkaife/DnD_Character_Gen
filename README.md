# DnD_Character_Gen

Full deployment making use of `terraform`, `ansible`, `docker` and, `kubernetes`.

## Using the Deployment

### Terraform

First, terraform needs to initilise the eks cluster.
It takes in three inputs as environment variables:

- access_key: **String**
- secret_key: **String**
- db_password: **String**

All pulled from system environment variables named;

- TF_VAR_access_key
- TF_VAR_secret_key
- TF_VAR_db_password

You can run all required commands once setting up the environment variables by running:

`NOTE: Don't forget to change the key_name in use in the EC2 module to one you have access to`

```bash
cd infrastructure/
./.deploy.sh
```

Terraform will create:

1 `VPC` containing:

- 3 Public `Subnets` across 3 AV
- 3 Private `Subnets` across 3 AV
- 1 `Internet Gateway`
- 1 `NAT Gateway`
- All required `Route-Tables`
- 1 `Subnet Group`

1 `EKS Cluster` making use of the previously created `VPC` containing:

- 2 `Auto-Scaling` Worker `Node Groups`
  - First starts at 2 `Node` capacity of t2.small
  - Second starts at 1 `Node` capacity of t2.medium
    - Both are configured to scale out or in as required.

2 `EC2` Instances

- First preconfigured to install `ansible`
- Second preconfigured to be used as a `jenkins` CI/CD server

1 `RDS` Instance

- Configured to launch into the `VPC`'s `subnet group`

Then, `terraform` will generate some needed files and attempt to push the changes to github.

### Manual Config

Second, you'll have to SSH onto the `jenkins` instance and configure the `aws cli`:

```bash
aws configure
```

Next, set up `kubectl` to use the `terraform` generated cluster:

```bash
aws eks --region eu-west-2 update-kubeconfig --name <NAME_GENERATED_BY_TERRAFORM>
# See outputs for cluster name
```

### Ansible

Back to technology assisted configuration;
SSH onto the `bastion` instance and clone down the updated version of the repo

```bash
git clone <YOUR-FORK>.git
```

`Terraform` should of generated an `inventory` file for you and automatically pushed it up.
Running the `ansible playbook` should be as easy as:

```bash
cd ./infrastructure/ansible
ansible-playbook -i inventory Playbook.yaml
```

`Ansible` will install `Docker`, `Jenkins`, configure an `artifact repository` and, launch the initial version of the app.

### Kubernetes

The app is 4 services managed by a `kubernetes` deployment, behind an `NGINX` load balancer.
The `Jenkinsfile` has been generated by `terraform` to work out of the box.
Simply set up a new `Job` to pull from the repository and look for a `Jenkinsfile` as the pipeline.

Whenever the `Job` triggers, `jenkins` will build new versions of the images, push them to the `artifact repository` (held on the `jenkins` instance) and then, perform a rolling update on the deployment.

```text
I know people are going to ask, the 
docker-compose is so each image doesn't 
have to be built seperately by ansible
```
